+++
date = '2025-06-29T01:28:22+09:00'
title = 'ABC 412'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc412>

## A. Task Failed Successfully

<https://atcoder.jp/contests/abc412/tasks/abc412_a>

## B. Precondition

<https://atcoder.jp/contests/abc412/tasks/abc412_b>

## C. Giant Domino

<https://atcoder.jp/contests/abc412/tasks/abc412_c>

できるだけ大きいドミノを選ぶのが最適。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    auto cal = []() -> void {
        int N;
        cin >> N;
        vll S(N);
        rep(i, N) cin >> S[i];

        ll st = S[0], fin = S[N - 1];
        S.erase(S.begin(), S.begin() + 1);
        S.pop_back();

        sort(all(S));
        S.push_back(INF);

        ll ans = 2;
        ll pr = st;
        rep(i, (ll)S.size() - 1) {
            if (S[i] <= pr) continue;
            if (fin <= pr * 2) break;
            if (S[i] <= pr * 2 && S[i + 1] > pr * 2) {
                pr = S[i];
                ans++;
            }
        }
        if (fin > pr * 2) ans = -1;
        cout << ans << '\n';
    };

    int T;
    cin >> T;
    rep(i, T) {
        cal();
    }
}
```

## D. Make 2-Regular Graph

<https://atcoder.jp/contests/abc412/tasks/abc412_d>

全ての頂点の次数が2であるようなグラフを全探索して、そのグラフにするために必要なコストを計算し、そのうち最小となるものを求める。
問題は条件を満たすグラフを全列挙する部分だが $1, 2, \cdots, N$ の順列を $P_1, P_2, \cdots, P_N$ としたとき、
$i, P_i$ 間に無向辺を張れば頂点の次数をたかだか 2 にすることができることに気づいた。
ただし $i = P_i$ の場合は次数 1 の頂点ができてしまうのでそのような場合は除外する。
$N \leq 8$ より全探索しても $8! = 40,320$ 通りしかないので十分に間に合う。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, M;
    cin >> N >> M;
    vvint grid(N, vint(N));
    rep(i, M) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        grid[a][b] = grid[b][a] = 1;
    }

    ll ans = INF;

    vint v(N);
    iota(all(v), 0);

    do {
        vector<set<int>> graph(N);
        rep(i, N) {
            graph[i].insert(v[i]);
            graph[v[i]].insert(i);
        }

        int ok = 1;
        rep(i, N) {
            if (graph[i].size() != 2) ok = 0;
        }
        if (!ok) continue;

        vvint tmp(N, vint(N));
        rep(i, N) {
            for (int nx : graph[i]) {
                tmp[i][nx] = 1;
            }
        }

        ll cnt = 0;
        rep(i, N) rep2(j, i + 1, N) {
            if (grid[i][j] != tmp[i][j]) cnt++;
        }
        chmin(ans, cnt);
    } while (next_permutation(all(v)));
    cout << ans << endl;
}
```

## E. LCM Sequence

<https://atcoder.jp/contests/abc412/tasks/abc412_e>

## F. Socks 4

<https://atcoder.jp/contests/abc412/tasks/abc412_f>

## G. Degree Harmony

<https://atcoder.jp/contests/abc412/tasks/abc412_g>
