+++
date = '2026-01-23T23:12:03+09:00'
title = 'ABC 149'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc149>

## A. Strings

<https://atcoder.jp/contests/abc149/tasks/abc149_a>

## B. Greedy Takahashi

<https://atcoder.jp/contests/abc149/tasks/abc149_b>

## C. Next Prime

<https://atcoder.jp/contests/abc149/tasks/abc149_c>

## D. Prediction and Restriction

<https://atcoder.jp/contests/abc149/tasks/abc149_d>

2026/1/22 あまりでまとめる系の問題だということを知った状態で自力 AC

<https://kenkoooo.com/atcoder/#/contest/show/bd593eb7-d83c-479e-a99d-d6242eff88ea?activeTab=Problems>

$i \equiv i + K \mod K$ が一致する $i$ ごとに独立に考えられるので、$K$ 個のグループに分けてそれぞれで勝てる手を選んでいけば良い。

$i$, $i+K$ で筐体が違う手を出す場合はそれぞれ勝つ手を単純に出せば良い。
同じ手が続く場合は片方で勝てる手を出し、もう片方は勝てない手を出す。勝たないときはポイントが入らないので、勝つ手、勝たない手(あいこ or 負け)を交互に出せば良い。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, K;
    cin >> N >> K;
    ll R, S, P;
    cin >> R >> S >> P;
    string T;
    cin >> T;

    vll v;
    rep(i, N) {
        ll x = 0;
        if (T[i] == 'r') x = 0;
        if (T[i] == 's') x = 1;
        if (T[i] == 'p') x = 2;
        v.push_back(x);
    }

    vll hand = {2, 0, 1};
    vll pt = {R, S, P};

    ll ans = 0;
    rep(s, K) {
        int i = s;
        int pr = -1;
        for (int j = i; j < N; j += K) {
            ll win = hand[v[j]];
            if (win == pr) {
                pr = -1;
            } else {
                ans += pt[win];
                pr = win;
            }
        }
    }
    cout << ans << endl;
}
```

## E. Handshake

<https://atcoder.jp/contests/abc149/tasks/abc149_e>

## F. Surrounded Nodes

<https://atcoder.jp/contests/abc149/tasks/abc149_f>
