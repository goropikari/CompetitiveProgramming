+++
date = '2026-01-12T23:31:10+09:00'
title = 'ABC 359'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc359>

## A. Count Takahashi

<https://atcoder.jp/contests/abc359/tasks/abc359_a>

## B. Couples

<https://atcoder.jp/contests/abc359/tasks/abc359_b>

## C. Tile Distance 2

<https://atcoder.jp/contests/abc359/tasks/abc359_c>

問題に影響ないのでスタート・ゴールともにタイルの左側として良い。
また $S_x > T_x$ の場合はスタートとゴールを入れ替えても問題ないので swap しておく。

$y$ 軸方向の移動は常に境界をまたぐので常に移動のたびに $|S_y - T_y|$ のコストがまずかかる。

$y$ 軸方向に移動するたびに右に一つずれることができるので最大で $S_x + |S_y - T_y|$ まで右にずれることができる。
もしそれでも $T_x$ に到達できない場合は、あとは $\frac{T_x - S_x + |S_y - T_y|}{2}$ 回の移動が必要になる。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    vll x(2), y(2);
    rep(i, 2) cin >> x[i] >> y[i];
    rep(i, 2) {
        if ((x[i] + y[i]) % 2 == 1) x[i]--;
    }
    if (x[0] > x[1]) {
        swap(x[0], x[1]);
        swap(y[0], y[1]);
    }

    ll ans = 0;
    ll absy = abs(y[0] - y[1]);

    x[0] += absy;
    if (x[0] < x[1]) {
        ans += abs(x[0] - x[1]) / 2;
    }

    ans += absy;
    cout << ans << endl;
}
```

## D. Avoid K Palindrome

<https://atcoder.jp/contests/abc359/tasks/abc359_d>

## E. Water Tank

<https://atcoder.jp/contests/abc359/tasks/abc359_e>

## F. Tree Degree Optimization

<https://atcoder.jp/contests/abc359/tasks/abc359_f>

## G. Sum of Tree Distance

<https://atcoder.jp/contests/abc359/tasks/abc359_g>
