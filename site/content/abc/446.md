+++
date = '2026-02-21T23:14:16+09:00'
title = 'ABC 446'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc446>

## A. Handmaid

<https://atcoder.jp/contests/abc446/tasks/abc446_a>

2026/2/21 コンテスト中に自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    cin >> s;

    s[0] ^= 32;
    s = "Of" + s;
    cout << s << endl;
}
```

## B. Greedy Draft

<https://atcoder.jp/contests/abc446/tasks/abc446_b>

2026/2/21 コンテスト中に自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, M;
    cin >> N >> M;

    vvint cand(N);
    rep(i, N) {
        ll l;
        cin >> l;
        while (l--) {
            ll x;
            cin >> x;
            cand[i].push_back(x);
        }
    }

    vint ans(N);
    vint used(M + 1);
    rep(i, N) {
        for (ll x : cand[i]) {
            if (!used[x]) {
                used[x] = 1;
                ans[i] = x;
                break;
            }
        }
    }

    for (ll x : ans) cout << x << endl;
}
```

## C. Omelette Restaurant

<https://atcoder.jp/contests/abc446/tasks/abc446_c>

2026/2/21 コンテスト中に自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    auto cal = []() -> void {
        ll N, D;
        cin >> N >> D;
        vll A(N), B(N);
        rep(i, N) cin >> A[i];
        rep(i, N) cin >> B[i];

        // num, day
        using P = pair<ll, ll>;
        deque<P> deq;

        rep(i, N) {
            deq.push_back({A[i], i});

            ll b = B[i];
            while (b) {
                ll mi = min(b, deq.front().first);
                b -= mi;
                deq.front().first -= mi;
                if (deq.front().first == 0) deq.pop_front();
            }

            while (deq.size() && deq.front().second + D <= i) deq.pop_front();
        }

        ll ans = 0;
        for (auto [num, d] : deq) ans += num;
        cout << ans << endl;
    };

    int t;
    cin >> t;
    rep(i, t) cal();
}
```

## D. Max Straight

<https://atcoder.jp/contests/abc446/tasks/abc446_d>

2026/2/21 コンテスト中に自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;
    vll A(N);
    rep(i, N) cin >> A[i];

    map<ll, ll> dp;
    for (ll a : A) {
        chmax(dp[a], dp[a - 1] + 1);
    }

    ll ans = 0;
    for (auto [k, v] : dp) chmax(ans, v);
    cout << ans << endl;
}
```

## E. Multiple-Free Sequences

<https://atcoder.jp/contests/abc446/tasks/abc446_e>

2026/2/21 コンテスト中に自力 AC

$M$ の倍数であるかどうかを調べればいいので $\mod M$ で考えて良い。
よって $s_n = A s_{n-1} + B s_{n-2} \mod M$ で考える。

$f(x, y)$ を $s_1 = x, s_2 = y$ として始めたときに $M$ の倍数が出るかどうかとする。
これをメモ化再帰で求める。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll M, A, B;
    cin >> M >> A >> B;
    A %= M;
    B %= M;

    vvint ng(M, vint(M));
    vvint visited(M, vint(M));

    auto dfs = [&](auto dfs, ll s1, ll s2) -> bool {
        // 結果が確定している
        if (s1 == 0 || s2 == 0) return false;
        if (ng[s1][s2]) return false;

        // 結果が確定していない、かつ、訪れたことがある状態に帰って来たとき
        // 道中 0 にならない繰り返しになるので以降 M の倍数は出ない
        if (visited[s1][s2]) {
            return true;
        }

        visited[s1][s2] = 1;
        ll s3 = (A * s2 + B * s1) % M;
        if (dfs(dfs, s2, s3)) {
            return true;
        }
        ng[s1][s2] = 1;
        return false;
    };

    ll ans = 0;
    rep(x, M) rep(y, M) {
        if (dfs(dfs, x, y))
            ans++;
    }

    cout << ans << endl;
}
```

## F. Reachable Set 2

<https://atcoder.jp/contests/abc446/tasks/abc446_f>

## G. 221 Subsequence

<https://atcoder.jp/contests/abc446/tasks/abc446_g>
