+++
date = '2026-01-23T23:01:32+09:00'
title = 'ABC 385'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc385>

## A. Equally

<https://atcoder.jp/contests/abc385/tasks/abc385_a>

## B. Santa Claus 1

<https://atcoder.jp/contests/abc385/tasks/abc385_b>

## C. Illuminate Buildings

<https://atcoder.jp/contests/abc385/tasks/abc385_c>

2026/1/22 余りでまとめる系の問題だということを知った状態で自力 AC

<https://kenkoooo.com/atcoder/#/contest/show/bd593eb7-d83c-479e-a99d-d6242eff88ea?activeTab=Problems>

幅 $w$ を固定したときに、$i$ から始まる列 $(H[i], H[i+w], H[i+2w], ...)$ の中で同じ値が連続する個数の最大値を求めれば良い。
$i \in [0, w)$ の範囲で全探索し、全ての幅 $w \in [1, N)$ について調べれば良い。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;
    vll H(N);
    rep(i, N) cin >> H[i];

    ll ans = 1;
    rep2(w, 1, N) {
        rep(i, w) {
            ll cnt = 0;
            for (int j = i; j < N; j += w) {
                cnt++;
                chmax(ans, cnt);
                if (j + w < N && H[j] != H[j + w]) cnt = 0;
            }
        }
    }
    cout << ans << endl;
}
```

## D. Santa Claus 2

<https://atcoder.jp/contests/abc385/tasks/abc385_d>

## E. Snowflake Tree

<https://atcoder.jp/contests/abc385/tasks/abc385_e>

## F. Visible Buildings

<https://atcoder.jp/contests/abc385/tasks/abc385_f>

## G. Counting Buildings

<https://atcoder.jp/contests/abc385/tasks/abc385_g>
