+++
date = '2026-01-20T00:07:10+09:00'
title = 'ABC 436'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc436>

## A. o-padding

<https://atcoder.jp/contests/abc436/tasks/abc436_a>

## B. Magic Square

<https://atcoder.jp/contests/abc436/tasks/abc436_b>

## C. 2x2 Placing

<https://atcoder.jp/contests/abc436/tasks/abc436_c>

## D. Teleport Maze

<https://atcoder.jp/contests/abc436/tasks/abc436_d>

## E. Minimum Swap

<https://atcoder.jp/contests/abc436/tasks/abc436_e>

## F. Starry Landscape Photo

<https://atcoder.jp/contests/abc436/tasks/abc436_f>

2026/1/20 segment tree の問題だとわかった状態で自力 AC

着目している星を $x$ とする。
$x$ が写真に映る星のなかで一番くらい星になるような写真のとり方は

<!-- dprint-ignore -->
\begin{align}
    &(\text{$x$ よりも左側にある $x$ よりも明るい星の個数 } + 1) \\\\
    &\times (\text{$x$ よりも右側にある $x$ よりも明るい星の個数 } + 1)
\end{align}

segment tree や fenwick tree などで各 index に存在する星の個数を持たせ、暗い星から順に見ていき、計算し、見終わったらその星を消すということを繰り返せばよい。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;
    vll B(N);
    rep(i, N) {
        cin >> B[i];
        B[i]--;
    }

    // number, id
    using P = pair<ll, ll>;
    vector<P> ps;
    rep(i, N) ps.emplace_back(B[i], i);
    sort(rall(ps), [](P a, P b) -> bool {
        return a.first < b.first;
    });

    fenwick_tree<ll> fw(N);
    rep(i, N) fw.add(i, 1);

    ll ans = 0;
    for (auto [_, id] : ps) {
        ll l = 1, r = 1;
        if (0 < id) {
            l += fw.sum(0, id);
        }
        if (id + 1 < N) {
            r += fw.sum(id + 1, N);
        }
        ans += l * r;
        fw.add(id, -1);
    }
    cout << ans << endl;
}
```

## G. Linear Inequation

<https://atcoder.jp/contests/abc436/tasks/abc436_g>
