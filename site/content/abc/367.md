+++
date = '2026-01-23T23:38:53+09:00'
title = 'ABC 367'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc367>

## A. Shout Everyday

<https://atcoder.jp/contests/abc367/tasks/abc367_a>

## B. Cut .0

<https://atcoder.jp/contests/abc367/tasks/abc367_b>

## C. Enumerate Sequences

<https://atcoder.jp/contests/abc367/tasks/abc367_c>

## D. Pedometer

<https://atcoder.jp/contests/abc367/tasks/abc367_d>

2026/1/22 あまりでまとめる系の問題だということを知った状態で自力 AC

<https://kenkoooo.com/atcoder/#/contest/show/bd593eb7-d83c-479e-a99d-d6242eff88ea?activeTab=Problems>

休憩所の番号を 0 始まりとする。休憩所 $N$ は 休憩所 0 を指す。

休憩所 0 から出発して、休憩所 $i$ に到達するまでの距離を $S_i$ とおく。

休憩所 $s$ から休憩所 $t$ までの距離は $S_t - S_s$ であるからこれが $M$ の倍数である条件は

<!-- dprint-ignore -->
\begin{align*}
    S_t - S_s &\equiv 0 \mod M \\\\
    S_t &\equiv S_s \mod M
\end{align*}

であるので $s$ から最も近い $S_t \equiv S_s \mod M$ を満たす $t$ を見つければ良い。ただし、 $s < t < s + N$ とする。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, M;
    cin >> N >> M;
    vll A(N);
    rep(i, N) cin >> A[i];

    vll cm(N * 2);
    rep(i, N * 2 - 1) {
        cm[i + 1] += cm[i] + A[i % N];
        cm[i + 1] %= M;
    }

    vvll mod(M);
    rep(i, N * 2 - 1) {
        mod[cm[i]].push_back(i);
    }

    ll ans = 0;
    rep(i, N) {
        ll m = cm[i];
        auto l = upper_bound(all(mod[m]), i);
        auto r = lower_bound(all(mod[m]), i + N);
        ans += r - l;
    }
    cout << ans << endl;
}
```

## E. Permute K times

<https://atcoder.jp/contests/abc367/tasks/abc367_e>

## F. Rearrange Query

<https://atcoder.jp/contests/abc367/tasks/abc367_f>

## G. Sum of (XOR^K or 0)

<https://atcoder.jp/contests/abc367/tasks/abc367_g>
