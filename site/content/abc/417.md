+++
date = '2025-08-11T03:58:10+09:00'
title = 'ABC 417'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc417>

## A. A Substring

<https://atcoder.jp/contests/abc417/tasks/abc417_a>

自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, A, B;
    cin >> N >> A >> B;
    string S;
    cin >> S;

    for (int i = A; i < N - B; i++) cout << S[i];
    cout << endl;
}
```

## B. Search and Delete

<https://atcoder.jp/contests/abc417/tasks/abc417_b>

自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    cin >> N >> M;
    multiset<ll> A;
    rep(i, N) {
        ll a;
        cin >> a;
        A.insert(a);
    }

    rep(i, M) {
        ll b;
        cin >> b;
        auto it = A.lower_bound(b);
        if (*it == b) {
            A.erase(it);
        }
    }

    vll ans;
    for (auto x : A) ans.push_back(x);
    print(ans);
}
```

## C. Distance Indicators

<https://atcoder.jp/contests/abc417/tasks/abc417_c>

自力 AC

$j - i = A_i + A_j \Rightarrow j - A_j = i + A_i$

$C = j - A_j = i + A_i$ と置き、$C = j - A_j$ となる $j$ と、$C = i + A_i$ となる $i$ をメモっておく。
$i = 1$ から順に $i < j$ かつ $i + A_i = j - A_j$ を満たす $j$ の個数を数える。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;
    vll A(N);
    rep(i, N) cin >> A[i];

    vll left;
    map<ll, vll> right;
    rep(i, N) {
        left.push_back(A[i] + i + 1);
        right[(i + 1) - A[i]].push_back(i);
    }

    ll ans = 0;
    rep(i, N) {
        ll a = left[i];
        auto it = upper_bound(all(right[a]), i);
        ans += right[a].end() - it;
    }
    cout << ans << endl;
}
```

## D. Takahashi's Expectation

<https://atcoder.jp/contests/abc417/tasks/abc417_d>

## E. A Path in A Dictionary

<https://atcoder.jp/contests/abc417/tasks/abc417_e>

自力 AC

距離を配列で取ってダイクストラしたら普通に AC してしまった。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    auto cal = [&]() -> void {
        ll N, M, X, Y;
        cin >> N >> M >> X >> Y;
        X--, Y--;
        vvint graph(N);
        rep(i, M) {
            int u, v;
            cin >> u >> v;
            u--, v--;
            graph[u].push_back(v);
            graph[v].push_back(u);
        }

        vvll dist(N);
        // dist, now
        using P = pair<vll, ll>;

        priority_queue<P, vector<P>, greater<P>> pq;
        vll v = {X};
        dist[X] = v;
        pq.push({v, X});
        while (pq.size()) {
            auto [d, now] = pq.top();
            pq.pop();

            if (dist[now] < d) continue;

            for (ll nx : graph[now]) {
                d.push_back(nx);
                if (dist[nx].size() && dist[nx] <= d) {
                    d.pop_back();
                    continue;
                }
                dist[nx] = d;
                pq.push({d, nx});
                d.pop_back();
            }
        }
        rep(i, dist[Y].size()) dist[Y][i]++;
        print(dist[Y]);
    };

    int t;
    cin >> t;
    rep(i, t) cal();
}
```

模範解答の DFS 版で書くとこう

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    auto cal = [&]() -> void {
        ll N, M, X, Y;
        cin >> N >> M >> X >> Y;
        X--, Y--;
        vvint graph(N);
        rep(i, M) {
            int u, v;
            cin >> u >> v;
            u--, v--;
            graph[u].push_back(v);
            graph[v].push_back(u);
        }

        for (auto& v : graph) sort(all(v));

        vector<bool> used(N);
        vint ans;

        auto dfs = [&](auto dfs, int now, vint& track) -> void {
            if (ans.size()) return;
            track.push_back(now);
            used[now] = true;

            if (now == Y) {
                ans = track;
                return;
            }

            for (int nx : graph[now]) {
                if (used[nx]) continue;
                dfs(dfs, nx, track);
            }
            track.pop_back();
        };

        vint v;
        dfs(dfs, (int)X, v);

        for (int& x : ans) x++;
        print(ans);
    };

    int t;
    cin >> t;
    rep(i, t) cal();
}
```

## F. Random Gathering

<https://atcoder.jp/contests/abc417/tasks/abc417_f>

## G. Binary Cat

<https://atcoder.jp/contests/abc417/tasks/abc417_g>
