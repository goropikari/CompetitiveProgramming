+++
date = '2026-02-01T00:16:56+09:00'
title = 'ABC 443'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc443>

## A. Append s

<https://atcoder.jp/contests/abc443/tasks/abc443_a>

2026/1/31 コンテスト中に自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    cin >> s;
    cout << s + "s" << endl;
}
```

## B. Setsubun

<https://atcoder.jp/contests/abc443/tasks/abc443_b>

2026/1/31 コンテスト中に自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, K;
    cin >> N >> K;

    ll sum = 0;
    rep(m, (ll)1e5) {
        sum += N + m;
        if (sum >= K) {
            cout << m << endl;
            return;
        }
    }
}
```

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, K;
    cin >> N >> K;

    auto f = [&](ll m) -> bool {
        ll sum = (m + 1) * N + m * (m + 1) / 2;
        return sum >= K;
    };

    ll wa = -1, ac = K;
    while (ac - wa > 1) {
        ll wj = (ac + wa) / 2;
        if (f(wj))
            ac = wj;
        else
            wa = wj;
    }
    cout << ac << endl;
}
```

## C. Chokutter Addiction

<https://atcoder.jp/contests/abc443/tasks/abc443_c>

2026/1/31 コンテスト中に自力 AC

高橋くんが chokutter を開く時間を $t$ とする。

- $t < A_i$ となる最小の $A_i$ まで開いているので $A_i - t$ を答えに加算
- $t = A_i + 100$ に更新

これを繰り返す。
コンテストでは $T$ を超えたときに loop を抜ける処理を入れてなかったせいで 1WA した。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, T;
    cin >> N >> T;
    vll A(N);
    rep(i, N) cin >> A[i];
    A.push_back(T);
    N++;

    ll ans = 0;
    ll now = 0;
    int i = 0;
    while (i < N && now < T) {
        while (i < N && A[i] < now) i++;
        ans += A[i] - now;
        now = A[i] + 100;
        i++;
    }
    cout << ans << endl;
}
```

## D. Pawn Line

<https://atcoder.jp/contests/abc443/tasks/abc443_d>

2026/1/31 コンテスト中に自力 AC

重要な制約としてコマは上方向にしか動かない。

これより1番上にあるコマは動かす必要がない。
行番号が小さいコマを基準に次のように処理していく

- 優先度付きキューに各コマの行番号とインデックスを格納する
  - 行番号が小さいものから取り出す
- 基準コマの行番号を `num` とする
- 基準コマの左右のコマを確認し、行番号が `num + 1` より大きい場合、`num + 1` に更新する
  - 動かした分を答えに加算し、優先度付きキューに `(num + 1, コマのインデックス)` を追加する
- これを優先度付きキューが空になるまで繰り返す

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    auto cal = []() -> void {
        ll N;
        cin >> N;
        vll R(N);
        rep(i, N) {
            cin >> R[i];
            R[i]--;
        }

        // row number, index
        using P = pair<ll, ll>;

        priority_queue<P, vector<P>, greater<P>> pq;
        rep(i, N) {
            pq.push({R[i], i});
        }

        ll ans = 0;
        while (pq.size()) {
            auto [num, base_id] = pq.top();
            pq.pop();

            if (R[base_id] < num) continue;
            for (ll d : {-1, 1}) {
                ll neigh_id = base_id + d;
                if (clamp(neigh_id, 0ll, N - 1) != neigh_id) continue;
                if (R[neigh_id] > num + 1) {
                    ans += R[neigh_id] - (num + 1);
                    R[neigh_id] = num + 1;
                    pq.push({num + 1, neigh_id});
                }
            }
        }
        cout << ans << '\n';
    };

    int t;
    cin >> t;
    rep(i, t) cal();
}
```

解説に書かれていた別解法。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    auto cal = []() -> void {
        ll N;
        cin >> N;
        vll R(N);
        rep(i, N) {
            cin >> R[i];
            R[i]--;
        }

        vll origin = R;
        rep(_, 2) {
            rep2(i, 1, N) {
                chmin(R[i], R[i - 1] + 1);
            }
            reverse(all(R));
        }

        ll ans = 0;
        rep(i, N) {
            ans += origin[i] - R[i];
        }
        cout << ans << '\n';
    };

    int t;
    cin >> t;
    rep(i, t) cal();
}
```

## E. Climbing Silver

<https://atcoder.jp/contests/abc443/tasks/abc443_e>

2026/1/31 コンテスト中に自力 AC

$B_i$ を $i$ 列目の壁を壊せるかどうかのフラグとする。
$(N,i)$ 壁がある場合は $B_i=1$ と初期化する。

- 各行を下から上に向かって BFS で探索する。
- 各マス $(r,j)$ について、$(r,j)$ に到達可能な場合、$(r-1,j-1),(r-1,j),(r-1,j+1)$ に移動可能か確認する
  - 移動先に壁がない場合
    - 移動可能
  - 移動先に壁がある場合
    - $B_{j^\prime} = 1$ なら移動不可
      - $j^\prime = j-1, j, j+1$
    - $B_{j^\prime} = 0$ なら壁を壊して移動可能とする
- $r$ 行目からの遷移を全て確認し終えたら、$B_i$ を更新する
  - $(r-1, i)$ に壁がある場合、$B_i=1$ とする
  - 壁がない場合、$B_i$ は更新しない

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    auto cal = []() -> void {
        ll N, C;
        cin >> N >> C;
        C--;

        vector<string> grid(N);
        rep(i, N) cin >> grid[i];

        vll blocks(N);
        rep(j, N) {
            if (grid[N - 1][j] == '#') blocks[j] = 1;
        }

        vvint dp(N, vint(N));
        dp[N - 1][C] = 1;

        vint dir = {-1, 0, 1};
        ll row = N - 1;
        rep(_, N - 1) {
            rep(j, N) {
                if (dp[row][j]) {
                    for (ll d : dir) {
                        ll nj = j + d;
                        if (clamp(nj, 0ll, N - 1) != nj) continue;
                        if (grid[row - 1][nj] == '#' && blocks[nj]) continue;
                        grid[row - 1][nj] = '.';
                        dp[row - 1][nj] = 1;
                    }
                }
            }

            row--;
            rep(j, N) {
                if (grid[row][j] == '#') blocks[j] = 1;
            }
        }

        string ans = "";
        rep(i, N) ans.push_back(dp[0][i] ? '1' : '0');
        cout << ans << '\n';
    };

    int t;
    cin >> t;
    rep(i, t) cal();
}
```

## F. Non-Increasing Number

<https://atcoder.jp/contests/abc443/tasks/abc443_f>

## G. Another Mod of Linear Problem

<https://atcoder.jp/contests/abc443/tasks/abc443_g>
