+++
date = '2026-02-14T23:29:13+09:00'
title = 'ABC 445'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc445>

## A. Strong Word

<https://atcoder.jp/contests/abc445/tasks/abc445_a>

2026/2/14 コンテスト中に自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    string S;
    cin >> S;
    yesno(S[0] == S.back());
}
```

## B. Center Alignment

<https://atcoder.jp/contests/abc445/tasks/abc445_b>

2026/2/14 コンテスト中に自力 AC

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;
    vector<string> S(N);
    rep(i, N) cin >> S[i];

    ll m = 0;
    rep(i, N) chmax(m, (ll)S[i].size());

    for (string s : S) {
        string ans = string(m, '.');
        int len = (m - s.size()) / 2;
        rep(i, (ll)s.size()) {
            ans[len + i] = s[i];
        }
        cout << ans << '\n';
    }
}
```

## C. Sugoroku Destination

<https://atcoder.jp/contests/abc445/tasks/abc445_c>

2026/2/14 コンテスト中に自力 AC

コンテスト中は $i \leq A_i \leq N$ という条件を見落としていて無理やりダブリングで通した。
Julia で $10^{100}$ の2のべき乗展開して無理やりダブリングで通したが配列を使い回すなどしてメモリを節約してどうにか通した。

公式解説読んでダブリングの要領で $10^i$ 回の操作後の位置を求めるテーブルを作る方法が上記の制約について気にせずに実装も楽で良さそうだった。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;
    vll A(N);
    rep(i, N) cin >> A[i];
    rep(i, N) A[i]--;

    // tens[i][j]: j にあるコマが 10^i の操作後にいる場所
    vvll tens(101, vll(N));
    tens[0] = A;

    rep2(i, 1, 101) {
        rep(j, N) {
            ll now = tens[i - 1][j];
            rep2(k, 1, 10) {
                now = tens[i - 1][now];
            }
            tens[i][j] = now;
        }
    }

    vll ans;
    rep(i, N) {
        ans.push_back(tens[100][i] + 1);
    }
    print(ans);
}
```

$i \leq A_i \leq N$ という条件より、留まるか右に移動するかの2択しかないので最大でも $N-1$ 回の操作以降は位置が変わらない。

後ろから位置が確定していくので、後ろから順に位置を更新していけば $O(N)$ で求めることができる。

コンテスト後に解説読んで解いた方法

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;
    vll A(N);
    rep(i, N) cin >> A[i];
    rep(i, N) A[i]--;

    vll ans(N);
    iota(all(ans), 0ll);
    for (int i = N - 2; i >= 0; i--) {
        ans[i] = ans[A[i]];
    }

    rep(i, N) ans[i]++;
    print(ans);
}
```

無理やりダブリングで通した方法

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;
    vll A(N);
    rep(i, N) cin >> A[i];
    rep(i, N) A[i]--;

    // 10^100 の2進数表記
    string ten_handred = "100100100100110101101001001011001010011000011011111001110101100001011001001111000010011000100110011100000101111110011100010101100111001000000100011100010000100011010011111001010101010110010010000110000100010101000001011101000111100010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

    int M = ten_handred.size();

    vll now(N);
    vll d = A, dn(N);
    iota(all(now), 0);
    rep(i, M) {
        rep(j, N) {
            ll nx = d[d[j]];
            dn[j] = nx;
        };
        swap(d, dn);
        if (ten_handred[i] == '0') continue;
        rep(j, N) {
            now[j] = d[now[j]];
        }
    }

    rep(i, N) now[i]++;
    print(now);
}
```

## D. Reconstruct Chocolate

<https://atcoder.jp/contests/abc445/tasks/abc445_d>

2026/2/14 コンテスト中に自力 AC

ピースを $H \times W$ の領域に配置していくことを考える。

ピースの作成方法から、ピースの置かれていない領域の縦か横の長さと一致するピースが少なくても一つは存在する。
いずれかに縦か横の長さが一致するピースがあればそれを領域の左上に配置していくことで条件を満たす配置ができる。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll H, W, N;
    cin >> H >> W >> N;
    using P = pair<ll, ll>;
    vector<P> chocos(N);
    rep(i, N) {
        ll h, w;
        cin >> h >> w;
        chocos[i] = {h, w};
    }

    ll r = 0, c = 0;

    // h,w,index
    using T = tuple<ll, ll, ll>;
    vector<T> rows(N), cols(N);
    rep(i, N) {
        rows[i] = cols[i] = {chocos[i].first, chocos[i].second, i};
    }

    auto opr = [](const T& a, const T& b) -> bool {
        auto [ar, ac, ai] = a;
        auto [br, bc, bi] = b;
        return ar > br;
    };
    auto opc = [](const T& a, const T& b) -> bool {
        auto [ar, ac, ai] = a;
        auto [br, bc, bi] = b;
        return ac > bc;
    };
    sort(all(rows), opr);
    sort(all(cols), opc);

    vint used(N);

    int ri = 0, ci = 0;

    vector<pair<ll, ll>> ans(N);

    rep(i, N) {
        while (ri < N) {
            auto [h, w, id] = rows[ri];
            if (!used[id]) break;
            ri++;
        }
        while (ci < N) {
            auto [h, w, id] = cols[ci];
            if (!used[id]) break;
            ci++;
        }

        if (ri < N) {
            auto [h, w, id] = rows[ri];
            if (H - r == h) {
                ans[id] = {r + 1, c + 1};
                c += w;
                used[id] = 1;
                continue;
            }
        }
        if (ci < N) {
            auto [h, w, id] = cols[ci];
            if (W - c == w) {
                ans[id] = {r + 1, c + 1};
                r += h;
                used[id] = 1;
            }
        }
    }

    for (auto [x, y] : ans) cout << x << ' ' << y << '\n';
}
```

## E. Many LCMs

<https://atcoder.jp/contests/abc445/tasks/abc445_e>

2026/2/14 解説 AC
方針はわかったが計算量を落とすことができなかった。

定数倍を落とさないといけなかったらしい。

$A_i = \prod_j p_j^{r_{i,j}}$ と素因数分解する。ここで $p_j$ は素数で  $r_{i,j} \geq 0$ である。

$e_{1, j}$ をすべての $A_i$ を素因数分解したときの $p_j$ の指数の最大値、$e_{2, j}$ を $p_j$ の指数の2番目に大きい値とする。

$ = \prod_j p_j^{e_{1,j}}$ であり、$A_i$ を使わないときの LCM は
$r_{i,j}$ が $e_{1,j}$ と等しいときは $p_j$ の指数を $e_{2,j}$ に変え、$e_{1,j}$ のままでいいから、$A_i$ を使わないときの LCM は $\mathrm{LCM}(A_1, \cdots, A_N)$ の値に対して
$r_{i,j} = e_{1,j}$ なら $p_j^{e_{1,j} - e_{2,j}}$ で割るということを全ての素因数に対して行えばよい。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    // ll M = (ll)1e7 + 1;
    // vll lpf(M);
    // iota(all(lpf), 0ll);
    // rep2(i, 2, M) {
    //     for (ll j = i + i; j < M; j += i) {
    //         if (lpf[j] > i)
    //             lpf[j] = i;
    //     }
    // }

    ll M = (ll)1e7 + 1;
    vll lpf(M, -1);
    vll primes;
    rep2(d, 2, M) {
        if (lpf[d] < 0) {
            lpf[d] = d;
            primes.push_back(d);
        }
        for (ll p : primes) {
            if (p * d > M || p > lpf[d]) break;
            lpf[p * d] = p;
        }
    }

    auto cal = [&]() -> void {
        ll N;
        cin >> N;
        vll A(N);
        rep(i, N) cin >> A[i];

        map<ll, ll> e1, e2;
        for (ll x : A) {
            while (x != 1) {
                ll p = lpf[x], cnt = 0;

                while (x % p == 0) {
                    cnt++;
                    x /= p;
                }

                if (cnt > e1[p]) {
                    e2[p] = e1[p];
                    e1[p] = cnt;
                } else if (cnt > e2[p]) {
                    e2[p] = cnt;
                }
            }
        }

        mint cm = 1;
        for (auto [p, cnt] : e1) {
            cm *= ((mint)p).pow(cnt);
        }

        vll ans;
        for (ll x : A) {
            mint mul = cm;
            while (x != 1) {
                ll p = lpf[x], cnt = 0;

                while (x % p == 0) {
                    cnt++;
                    x /= p;
                }

                if (cnt == e1[p]) {
                    mul /= (mint(p).pow(e1[p] - e2[p]));
                }
            }
            ans.push_back(mul.val());
        }
        print(ans);
    };

    int t;
    cin >> t;
    rep(i, t) cal();
}
```

## F. Exactly K Steps 2

<https://atcoder.jp/contests/abc445/tasks/abc445_f>

2026/2/15 自力 AC

ダブリングで解く。

$D(d, i, j)$ を $j$ から出発して $2^d$ 回の操作後に $i$ に到達するときの最小コストとすると、
$D(d, i, j) = \min_k \\\{ D(d-1, i, k) + D(d-1, k, j) \\\}$ である。$0$ 回の操作のときの初期値は対角成分が 0、それ以外は $\infty$ とする。

これより $K$ 回の操作後の最小コストを求めて、対角成分について出力すれば良い。

```cpp
struct Cost {
    ll N;
    vvll data;

    Cost(ll N) : N(N) {
        data = vvll(N, vll(N, INF));
        rep(i, N) data[i][i] = 0;
    }

    Cost operator*(const Cost& other) {
        vvll vals(N, vll(N, INF));

        rep(k, N) rep(i, N) rep(j, N) {
            chmin(vals[i][j], this->data[i][k] + other.data[k][j]);
        }

        Cost ret(N);
        ret.data = vals;
        return ret;
    }
};

void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, K;
    cin >> N >> K;
    vvll C(N, vll(N));
    rep(i, N) rep(j, N) cin >> C[i][j];

    ll M = 31;

    // powcost[d][i][j]: j から出発して 2^d の操作後に i に到達するときの最小コスト
    vector powcost(M, Cost(N));
    powcost[0].data = C;
    rep2(d, 1, M) {
        powcost[d] = powcost[d - 1] * powcost[d - 1];
    }

    Cost now(N);
    rep(i, M) {
        if (K >> i & 1) {
            now = powcost[i] * now;
        }
    }

    vll ans;
    rep(i, N) {
        cout << now.data[i][i] << '\n';
    }
}
```

## G. Knight Placement

<https://atcoder.jp/contests/abc445/tasks/abc445_g>
