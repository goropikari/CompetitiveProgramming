+++
date = '2026-01-20T00:58:17+09:00'
title = 'ABC 343'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc343>

## A. Wrong Answer

<https://atcoder.jp/contests/abc343/tasks/abc343_a>

## B. Adjacency Matrix

<https://atcoder.jp/contests/abc343/tasks/abc343_b>

## C. 343

<https://atcoder.jp/contests/abc343/tasks/abc343_c>

## D. Diversity of Scores

<https://atcoder.jp/contests/abc343/tasks/abc343_d>

## E. 7x7x7

<https://atcoder.jp/contests/abc343/tasks/abc343_e>

## F. Second Largest Query

<https://atcoder.jp/contests/abc343/tasks/abc343_f>

2026/1/19 segment tree の問題だとわかった状態で自力 AC

<https://kenkoooo.com/atcoder/#/contest/show/76c42792-10db-491b-9486-ffc7f4f226e1?activeTab=Standings>

一番大きい値とその個数、二番目に大きい値とその個数を segment tree に持たせればよい。

```cpp
struct S {
    ll fir, fn;
    ll sec, sn;
};

S op(S a, S b) {
    map<ll, ll> mp;
    mp[a.fir] += a.fn;
    mp[a.sec] += a.sn;
    mp[b.fir] += b.fn;
    mp[b.sec] += b.sn;

    auto it = mp.rbegin();
    ll fir = it->first, fn = it->second;
    it++;
    ll sec = it->first, sn = it->second;
    return {fir, fn, sec, sn};
}

S e() {
    return S({0, 0, 0, 0});
}

void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, Q;
    cin >> N >> Q;
    vll A(N);
    rep(i, N) cin >> A[i];

    segtree<S, op, e> seg(N);
    rep(i, N) {
        seg.set(i, {A[i], 1, 0, 0});
    }

    while (Q--) {
        int t;
        cin >> t;
        if (t == 1) {
            ll p, x;
            cin >> p >> x;
            p--;
            seg.set(p, {x, 1, 0, 0});
        } else {
            ll l, r;
            cin >> l >> r;
            l--;
            S v = seg.prod(l, r);
            cout << v.sn << endl;
        }
    }
}
```

## G. Compress Strings

<https://atcoder.jp/contests/abc343/tasks/abc343_g>
