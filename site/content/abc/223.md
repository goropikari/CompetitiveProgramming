+++
date = '2024-12-22T02:13:32+09:00'
title = 'ABC 223'
tags = ["atcoder", "abc"]
+++

<https://atcoder.jp/contests/abc223>

## A. Exact Price

<https://atcoder.jp/contests/abc223/tasks/abc223_a>

## B. String Shifting

<https://atcoder.jp/contests/abc223/tasks/abc223_b>

## C. Doukasen

<https://atcoder.jp/contests/abc223/tasks/abc223_c>

解説の解説

ぶつかる地点を $x$ とする。左端から $x$ まで行く時間を $t_l$, 右端から $x$ まで行く時間を $t_r$ とすると当たり前だが $t_l = t_r$ が成り立つ。
一方、 左端からだけ燃やしたときにすべてが燃えるのにかかる時間は $T = \sum^{N}_{i=1}\frac{A_i}{B_i}$ である。
$t = t_l$ とすると $2t = T$ であるから

$t = \frac{1}{2} \sum_{i=1}^{N}\frac{A_i}{B_i}$

である。

## D. Restricted Permutation

<https://atcoder.jp/contests/abc223/tasks/abc223_d>

## E. Placing Rectangles

<https://atcoder.jp/contests/abc223/tasks/abc223_e>

## F. Parenthesis Checking

<https://atcoder.jp/contests/abc223/tasks/abc223_f>

2026/2/16 segment tree の問題だとわかった状態で自力 AC

<https://kenkoooo.com/atcoder/#/contest/show/76c42792-10db-491b-9486-ffc7f4f226e1?activeTab=Standings>

左側にある余剰な右括弧の数と、右側にある余剰な左括弧の数を管理するセグメントツリーを構築する。
左側の区間の余剰の左括弧の数と、右側の区間の余剰の右括弧の数をマージする際に、両方とも余剰がある場合は、マッチングさせて減らす。

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, Q;
    string S;
    cin >> N >> Q >> S;

    using P = pair<ll, ll>;
    auto op = [](P a, P b) -> P {
        ll m = min(a.second, b.first);
        return {a.first + b.first - m, b.second + a.second - m};
    };

    auto e = []() -> P {
        return {0, 0};
    };

    segtree<P, op, e> seg(N);
    rep(i, N) {
        if (S[i] == ')')
            seg.set(i, {1, 0});
        else
            seg.set(i, {0, 1});
    }

    while (Q--) {
        ll t, l, r;
        cin >> t >> l >> r;
        l--, r--;
        if (t == 1) {
            P left = seg.get(l), right = seg.get(r);
            swap(left, right);
            seg.set(l, left);
            seg.set(r, right);
        } else {
            P ret = seg.prod(l, r + 1);
            yesno(ret.first == 0 && ret.second == 0);
        }
    }
}
```

解説放送での実装

```cpp
struct P {
    ll sum, mi;
};

P op(P a, P b) {
    return {a.sum + b.sum, min(a.mi, a.sum + b.mi)};
}

P e() {
    return {0, 0};
}

void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N, Q;
    string S;
    cin >> N >> Q >> S;

    segtree<P, op, e> seg(N);
    rep(i, N) {
        if (S[i] == '(')
            seg.set(i, {1, 0});
        else
            seg.set(i, {-1, -1});
    }

    while (Q--) {
        int t;
        cin >> t;
        if (t == 1) {
            ll l, r;
            cin >> l >> r;
            l--, r--;
            P a = seg.get(l), b = seg.get(r);
            swap(a, b);
            seg.set(l, a), seg.set(r, b);
        } else {
            ll l, r;
            cin >> l >> r;
            l--;
            P p = seg.prod(l, r);
            yesno(p.sum == 0 && p.mi == 0);
        }
    }
}
```

## G. Vertex Deletion

<https://atcoder.jp/contests/abc223/tasks/abc223_g>

## H. Xor Query

<https://atcoder.jp/contests/abc223/tasks/abc223_h>
