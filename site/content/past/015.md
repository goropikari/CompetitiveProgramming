+++
date = '2025-04-07T01:18:45+09:00'
title = '第15回 アルゴリズム実技検定(過去問) (PAST 015)'
tags = ['atcoder', 'past']
+++

<https://atcoder.jp/contests/past15-open>

## E - 合計得点

bit 全探索で良いが $N$ 個から $K$ 個選ぶ方法でも解ける

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    cin >> n >> k;
    vll a(n);
    rep(i, n) cin >> a[i];

    vint v;

    auto dfs = [&](auto dfs, int used) -> void {
        if (__builtin_popcount(used) == k) {
            v.push_back(used);
            return;
        }

        int id = -1;
        rep(i, n) {
            if ((used >> i) & 1)
                id = i;
        }
        rep2(i, id + 1, n) {
            dfs(dfs, used | (1 << i));
        }
    };

    dfs(dfs, 0);

    ll ans = 0;
    for (int used : v) {
        rep(i, n) {
            if ((used >> i) & 1)
                ans += a[i];
        }
    }
    cout << ans << endl;
}
```

## F - 番号付け

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    vint A(N);
    rep(i, N) cin >> A[i];

    map<int, vint> mp;
    rep(i, N) {
        mp[A[i]].push_back(i);
    }

    int cnt = 1;
    vint ans(N);
    for (auto it = mp.begin(); it != mp.end(); it++) {
        auto [_, ids] = *it;
        for (int id : ids) {
            ans[id] = cnt++;
        }
    }
    print(ans);
}
```

## G - N-SAT

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    cin >> N >> M;
    vvint as(M), bs(M);
    rep(i, M) {
        int k;
        cin >> k;
        rep(j, k) {
            int a, b;
            cin >> a >> b;
            a--;
            as[i].push_back(a);
            bs[i].push_back(b);
        }
    }

    rep(t, 1 << N) {
        vint xs;
        rep(i, N) {
            xs.push_back((t >> i) & 1);
        }

        int cnt = 0;
        rep(i, M) {
            int ok = 0;
            int ki = as[i].size();
            rep(j, ki) {
                if (xs[as[i][j]] == bs[i][j])
                    ok = 1;
            }
            if (ok)
                cnt++;
        }

        if (cnt == M) {
            yesno(true);
            return;
        }
    }
    yesno(false);
}
```

## H - 和で表現

解説 AC。愚直解で AC 取れてしまったが解説読んだら二分探索だった。

愚直解

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;

    auto sum = [](ll n) -> ll {
        return n * (n + 1) / 2;
    };

    int i = 0;
    while (sum(i) <= N)
        i++;
    cout << i - 1 << endl;
}
```

二分探索

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    ll N;
    cin >> N;

    auto sum = [](ll n) -> ll {
        return n * (n + 1) / 2;
    };

    ll ac = 0, wa = (ll)2e9 + 7;
    while (wa - ac > 1) {
        ll wj = (wa + ac) / 2;
        if (sum(wj) <= N)
            ac = wj;
        else
            wa = wj;
    }
    cout << ac << endl;
}
```

## I - 最大公約数の最大値

$A_i$ の約数を列挙して、出現頻度が $K$ 以上のもののうち最大の数が答え

```cpp
void solve() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, K;
    cin >> N >> K;
    vint A(N);
    rep(i, N) cin >> A[i];

    int mx = (int)1e6 + 5;
    vvint divs(mx);
    rep2(i, 1, mx) {
        for (int j = i; j < mx; j += i) {
            divs[j].push_back(i);
        }
    }

    vint v(mx);
    for (int a : A) {
        for (int d : divs[a]) {
            v[d]++;
        }
    }

    int ans = 1;
    rep(i, mx) {
        if (v[i] >= K)
            ans = i;
    }
    cout << ans << endl;
}
```
